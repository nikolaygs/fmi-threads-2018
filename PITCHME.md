## Многонишково програмиране с Java

---

### Съдържание

- Въведение
- Управление на нишки 
- Споделяне на ресурси 
- Комуникация между нишки 
- Преизползване на нишки 
- Атомарни променливи
- Конкурентни колекции

---

![Flux Explained](https://me.me/i/17324460)

---

### Какво е нишка?

Отделен път на изпълнение в програма, който се изпълнява асинхронно

---

### Асинхронно изпълнение
- Многозадачност
- Многонишковост

---

### Процеси и нишки


---
#### Ползи от многонишковото изпълнение
- Пълноценна употреба на наличните ресурси 
- Подобрено потребителско усещане
- Подобрен дизайн
---
#### Предизвикателства
- Сложност на кода
- Източник на грешки

---

## Управление на нишки

---

### Java + нишки
- управление на нишки – java.lang.Thread
- синхронизация при достъп – ключовата дума synchronized
- комуникация между нишки – Object.wait() / notify()

---

### Диспечер на нишки
- Java диспечер (green thread scheduler)
- Диспечър на ОС

---

### Дефиниране на нишка
- Всяка Java програма при стартирането си съдържа една нишка (main)
- За да създадем нова нишка в Java, наследяваме класа java.lang.Thread
- Инструкциите за изпълнение поставяме в метода run() който не връща резултат

@fa[arrow-down]

+++

```
public class CustomThread extends Thread { public void run() { System.out.println("Hello asynchronous world!"); } }
```

---

### Стартиране на нишка
За да стартираме нишка, трябва да:
- инстанцираме класа, представляващ нишка
- извикаме метода start() (който вътрешно ще извика run())

---

### Спиране на нишка
- Нишката прекратява изпълнението си автоматично след приключването на метода run()
- Нишката не може да бъде стартирана повторно!

---

### java.lang.Runnable
- Нишка може да бъде дефинирана и чрез интерфейса java.lang.Runnable
- За да стартираме нишката, подаваме инстанция на конкретния клас на java.lang.Thread
---

### Thread vs Runnable
При употреба на Runnable сме по-гъвкави:
- наследяване на друг клас
- можем да решим да изпълним имплементацията в: 
--друга нишка 
--чрез thread pool
--в текущата нишка

---

### Thread API

Програмистът може да именува нишката чрез setName(). Имената нe са уникални!
```
customThread.setName("Cool thread #1");
```

@fa[arrow-down]
+++

Също така, нишките могат да се групират логически чрез ThreadGroup. Групата може да се задава само чрез конструктора.
```
ThreadGroup coolThreads = new ThreadGroup("Cool thread group"); // Конструктор, който приема група и име 
coolThread1 = new Thread(coolThreads, "Cool thread #1"); 
coolThread2 = new Thread(coolThreads, "Cool thread #2");
```

---
### Thread API

„Спане“ – нишката „заспива“ и не получава процесорно време за определен интервал време

```
Thread.sleep(long miliseconds)
```

Референция към текущата нишка
```
Thread.currentThread()
```

Stack trace-а на нишката
```
Thread.getStackTrace()
```
---
### Приоритет на нишки

Подсказка към диспечера на нишки, каква част от процесорното време да получи дадена нишка чрез метода setPriority()

Скалата е от 1 (най-нисък) до 10 (най-висок). Приоритетът по подразбиране е 5.

@fa[arrow-down]
+++
Отстъпване на процесорно време чрез метода yield() - сигнал, че текущата нишка се отказва от своето процесорно време в полза на друга нишка, чийто приоритет е минимум колкото този на текущата

---
### Прекъсване на нишка
Механизъм, чрез който една нишка може да съобщи на друга да спре изпълнението си
```
customThread.interrupt()
```

Какво действие ще се извърши в нишката, зависи изцяло от програмиста, възможно е сигналът да се игнорира

@fa[arrow-down]
+++

Нишката може да провери дали е била прекъсната чрез методите:
```
Thread.interrupted() // изчиства флага след прочитането (статичен)
isInterrupted() // не изчиства флага (не-статичен)
```
@fa[arrow-down]
+++
Някой методи (sleep / join) хвърлят изключение java.lang.InterruptedException, когато нишката e получила сигнал за прекъсване, докато те се изпълняват
---

