## Многонишково програмиране с Java
_27.11.2018_

---

#### Съдържание

- Въведение
- Управление на нишки 
- Споделяне на ресурси 
- Комуникация между нишки 
- Преизползване на нишки 
- Атомарни променливи
- Конкурентни колекции

---

![dogs-meme](https://cdn-images-1.medium.com/max/1600/0*9LJYn6Tlc8q3qA3U.png)

---

#### Какво е нишка?

Отделен път на изпълнение в програма, който се изпълнява конкурентно.

---

#### Конкурентно изпълнение
- Многозадачност
- Многонишковост

---

#### Процеси и нишки

|               | Процеси     | Нишки  |
| ------------- |-------------| -----|
| Стартиране    | Бавно | Относително бързо |
| Изолация      | Да    |   Не |
| Комуникация   | Бавна |    Бърза |

---
#### Ползи от многонишковото изпълнение
- Пълноценна употреба на наличните ресурси 
- Подобрено потребителско усещане
- Подобрен дизайн

---

#### Предизвикателства
- Сложност на кода
- Източник на грешки

---

## Управление на нишки

---

#### Java + нишки

@ul
- управление на нишки – java.lang.Thread
- синхронизация при достъп – ключовата дума synchronized
- комуникация между нишки – Object.wait() / notify()
@ulend

---

#### Диспечер на нишки
- Java диспечер (green thread scheduler)
- Диспечър на операционната система

---

#### Дефиниране на нишка
@ul
- Всяка Java програма при стартирането си съдържа една нишка (main)
- За да създадем нова нишка в Java, наследяваме класа java.lang.Thread
- Инструкциите за изпълнение поставяме в метода run() който не връща резултат
@ulend

@fa[arrow-down]

+++

```
public class CustomThread extends Thread { 
  public void run() {
    System.out.println("Hello asynchronous world!");
  } 
}
```

---

#### Стартиране на нишка
@ul
За да стартираме нишка, трябва да:
- инстанцираме класа, представляващ нишка
- извикаме метода start() (който вътрешно ще извика run())
@ulend

---

#### Спиране на нишка

@ul
- Нишката прекратява изпълнението си автоматично след приключването на метода run()
- Нишката не може да бъде стартирана повторно!
@ulend

---

__java.lang.Runnable__  
Нишка може да бъде дефинирана и чрез интерфейса java.lang.Runnable

```
class CustomRunnable implements Runnable {
  public void run() {
    System.out.println("Hello asynchronous world!");
  }
}
```

@fa[arrow-down]
+++

За да стартираме нишката подаваме инстанция на конкретния клас на java.lang.Thread.
```
Thread customThread = new Thread(new CustomRunnable());
```

---

__Thread vs Runnable__ 

При употреба на Runnable сме по-гъвкави:

@ul
- наследяване на друг клас
- можем да решим да изпълним имплементацията в:  
  - друга нишка 
  - чрез thread pool
  - в текущата нишка
@ulend

---

__Thread API__  

Програмистът може да именува нишката чрез setName(). Имената нe са уникални!
```
customThread.setName("Cool thread #1");
```

@fa[arrow-down]
+++

Също така, нишките могат да се групират логически чрез ThreadGroup. Групата може да се задава само чрез конструктора.
```
// Конструктор, който приема група и име 
ThreadGroup coolThreads = new ThreadGroup("Cool thread group");
coolThread1 = new Thread(coolThreads, "Cool thread #1"); 
coolThread2 = new Thread(coolThreads, "Cool thread #2");
```

---
__Thread API__

```
// „Спане“ – нишката „заспива“ и не получава процесорно време 
// за определен интервал време
Thread.sleep(long miliseconds)

// Референция към текущата нишка
Thread.currentThread()

// Stack trace-а на нишката
Thread.getStackTrace()
```

---

__Приоритет на нишки__

```
// Подсказка към диспечера на нишки, каква част от процесорното
// време да получи дадена нишка. Скалата е от 1 до 10. 
// Приоритетът по подразбиране е 5.
void setPriority(int prio)

// Tекущата нишка се отказва от своето процесорно време в полза 
// на друга, чийто приоритет е минимум колкото този на текущата
void yield()
```

---
#### Прекъсване на нишка
Eдна нишка може да съобщи на друга да спре изпълнението си чрез:

```
customThread.interrupt()
```

@fa[arrow-down]
+++

Какво действие ще се извърши в нишката, зависи изцяло от програмиста, възможно е сигналът да се игнорира

@fa[arrow-down]
+++

Нишката може да провери дали е била прекъсната чрез методите:

```
Thread.interrupted() // изчиства флага след прочитането (статичен)
isInterrupted() // не изчиства флага (не-статичен)
```

@fa[arrow-down]
+++

__java.lang.InterruptedException__

Някой методи (sleep / join) хвърлят изключение java.lang.InterruptedException, когато нишката e получила сигнал за прекъсване, докато те се изпълняват

---

#### Присъединяване към друга нишка

Дадена нишка може да паузира изпълнението си, докато друга нишка приключи чрез метода join()

![Flux Explained](https://www.bogotobogo.com/cplusplus/C11/images/thread_1_intro/real_fork_join.png)

@fa[arrow-down]
+++

__Thread.join()__

```
// Извикващата нишка блокира, докато нишката на която е извикала
// join приключи
void join()

// Ако нишката приключи или зададеното време изтече извикващата
// нишка ще продължи изпълнението си.
void join(long millis)

// Можем да проверим дали дадена нишка не е приключила изпълнението си.
boolean isAlive()
```

---

#### Daemon нишки
Според режима на работа, нишките в Java могат да бъдат два вида:
- Стандартни (non-daemon) нишки
- Демон (daemon) нишки

@fa[arrow-down]
+++

__Стандартни нишки__  
Изпълняват задачи, които са свързани с основната идея на програмата. Всяка JVM работи, докато има поне една стандартна нишка, която още не е приключила с изпълнение на своята задача

@fa[arrow-down]
+++

__Daemon__  
изпълняват задачи, които не са част от логиката на програмата, а по-скоро се класифицират като общи услуги. JVM ще прекрати работата на нишките от този тип, без значение от състоянието в което се намират, ако няма поне една работеща стандартна нишка

@fa[arrow-down]
+++

Нишките наследяват режима на работа от тази, която ги е създала. Той подлежи на промяна чрез извикване на метода java.lang.Thread.setDaemon().

---

#### Състояние на нишка
- Нишката може да бъде в различно състояние в даден момент от изпълнението си (жизнения си цикъл).
- Методът getState() ни дава възможност да проверим моментното състояние на нишка.

@fa[arrow-down]
+++

__Thread.State__
enum съдържащ всички възможни състояния:  
NEW   
RUNNABLE  
BLOCKED  
WAITING  
TIMED_WAITING  
TERMINATED  

@fa[arrow-down]
+++

![thread-states](http://www.ooxs.be/images/java/thread-states.png)

---

## Споделяне на ресурси

---

#### Синхронизирана секция

Когато две или повече нишки достъпват конкурентно даден ресурс, който може да бъде променян, е необходима синхронизация.

В Java това се постига чрез ключовата дума synchronized 

@fa[arrow-down]
+++

Състои се от две части: 
- монитор – логическа „ключалка“ 
- блок код, който ще се изпълни ексклузивно от една нишка за даден монитор.

@fa[arrow-down]
+++

```
  public void depositMoney(BankAccount acc, double amount) {
    // Много нишки могат да изпълнят конкурентно кода тук
    System.out.println("Depositing " + amount + " to " + acc);
    
    // Критична секция – една-единствена нишка за дадена сметка 
    // acc може изпълнява кода в синхронизираната секция
    synchronized (acc) {
      acc.deposit(amount);
    }

    // Не-критична секция - много нишки могат да бъдат тук 
    System.out.println("Deposit completed");
  }
```

---

#### Синхронизирана секция
@ul
- Всеки обект има вътрешен имплицитен монитор (ключалка, lock) т.е. може да се ползва за монитор
- Чрез ключовата дума synchronized се маркира критична секция по даден монитор
- Само една нишка в даден момент може да изпълнява кода (mutex)
@ulend

@fa[arrow-down]
+++

Мониторът се управлява имплицитно от JVM: 
- при влизане в критична секция, ако е свободен -> се маркира за „зает“ от съответната нишка 
- при влизане в критична секция, ако не е свободен -> нишката блокира 
- при излизане от критичната секция -> lock-ът се освобождава и ако има блокирани нишки те могат да се опитат да вземат ключалката

@fa[arrow-down]
+++

Имаме последователен достъп от нишките на кода в синхронизираните секции по един и същ монитор (серийно изпълнение).

synchronized също така задава правила на видимост на данни между нишките

@fa[arrow-down]
+++

Правило - всеки достъп на даден ресурс, който може да бъде променян от друга нишка, трябва винаги да става в синхронизирана секция, по един и същ монитор!

@fa[arrow-down]
+++

Статус при синхронизация

---

#### Синхронизиран метод
Много често искаме да поставим цялото тяло на даден метод в критична секция. С цел по-четим код, Java ни предлага по-сбит вариант.

@fa[arrow-down]
+++

```
  public void doSomeWork() {
    synchronized (this) {
      // Критична секция, само една нишка може да
      // изпълнява кода за конкретната инстанция 'this'
    }
  }
```
може да се напише съкратено до:

```
  public synchronized void doSomeWork() { 
    // Критична секция, само една нишка може да 
    // изпълнява кода за конкретната инстанция 'this' 
    } 
  }
```

---
#### Синхронизирана секция или метод?

Методът е най-голямата възможна област която може да бъде маркирана като критична. Препоръчва се само, ако методът е достатъчно кратък (и бърз за изпълнение) и наистина има нужда цялото тяло да бъде „охранявано"

@fa[arrow-down]
+++

Синхронизираната секция е за предпочитане, когато:
@ul
- нуждаещото се от синхронизация парче код е малка част от метод
- искаме да ползаваме монитор различен от ```this```
@ulend

---
####  Рекурсивност

Lock-ът е рекурсивен (reentrant): нишката, която го „притежава“, може да извиква други критични секции по същия монитор.

@fa[arrow-down]
+++

```
class Demo {
  public void method1() {
    synchronized (this) {
      // изпълняващата нишка вече притежава lock-а
      // следователно може да извика method2()
      method2();
    }
  }

  public synchronized method2() {
  }
}
```
---

#### Използване на монитор, различен от ```this```

В определени случаи, може да изберем да синхронизираме достъпа в дадена инстанция на обект чрез „отдадена“ член променлива.
```
private final Object dedicatedMonitor = new Object();
```

@fa[arrow-down]
+++

- енкапсулираме монитора, но използваме допълнителна памет
- даден клас има нужда от различни монитори за охраняване на различно състояние

---

#### Използване на няколко монитора 
Една нишка може да „притежава“ много на брой монитори, стига те да са свободни:

```
  public void multipleLocks() {
    synchronized (lock1) {
      // нишката притежава lock1
      synchronized (lock2) {
        // нишката притежава lock1 & lock2
        synchronized (lock3) {
          // нишката притежава lock1, lock2 & lock3
        }
        // нишката притежава lock1 & lock2
      }
      // нишката притежава lock1
    }
  }
```
NB! Държането на няколко ключалки е лоша практика и при възможност трябва да се избягва.

---

#### Синхронизация между инстанции на клас
@ul
- Подходящо е да ползваме ключалка, обща за класа 
- … разбира се, най-удобно е да ползваме статична променлива за монитор.
@ulend

@fa[arrow-down]
+++

Всяка инстанция на клас има статична референция към обекта на класа, към който принадлежи, може да я достъпим чрез:

```
BankAccount.class // статично
this.getClass() // чрез ‘this’
```

---

#### Статични синхронизирани методи
Java отново ни предоставя съкратен вариант:
```
  static void incrementOpCount() {
    synchronized (BankAccount.class) {
      opCount++;
    }
  }
```
може да се напише съкратено като:
```
  static synchronized void incrementOpCount() {
    opCount++;
  }
```

---
#### Thread-safe обекти
Някой обекти са thread-safe по подразбиране:
- Локални обекти
- Stateless обекти
- Immutable обекти
- Обекти, които са ефективно final (read-only)


---

#### ```volatile``` променливи

@ul
- JVM гарантира, че простите операции върху примитиви с размер до 32 бита ще бъдат третирани като неделими. 
- Това изключва променливите от тип long и double
@ulend

@fa[arrow-down]
+++

Четенето и писането на 64 бита може да бъде разделено на 2 операции, което може да доведе до неконсистентност:

```
1. Изпълнява се първата 32 битова операция 
2. Диспечерът на нишките сменя контекста на процесора 
3. По същото време, друга нишка достъпва 64-битовата променлива и работи с частично променени данни
```

@fa[arrow-down]
+++

Дефинирането на променлива като volatile ни гарантира:
- Атомарност – простите операции върху 64-битови примитиви са неделими
- Видимост – стойността на променливата се чете и съхранява директно в паметта. 

@fa[arrow-down]
+++

NB! Ключовата дума volatile осигурява атомарност само и единствено на простите операции върху примитиви. За създаване на съставни неделими операции трябва да се използват синхронизирани блокове

---

## Проблеми при конкурентен достъп до ресурси

---

#### Race condition
@ul
- Коректността на приложението зависи от реда на изпълнение на нишките
- Проблемът може да стои незабелязан дълго време
- Обикновено е трудно откриваема грешка
@ulend
---

#### Бързодействие

@ul
- Синхронизацията е относително бавна операция
- Ако критичната ни секция е ненужно голяма, може да забави изпълнението понеже нишките се изпълняват серийно.
@ulend

@fa[arrow-down]
+++

@ul
- Препоръчително е да поставим в критична секция единствено кода, който достъпва променливи, които могат да бъдат конкурентно модифицирани.
- NB! Винаги правете кода си първо коректен после бързодействащ!
@ulend

---

#### Съставни операции

Ако комбинираме няколко thread-safe операции в една по-сложна (обща), нямаме никаква гаранция, че те ще се изпълнят атомарно

@fa[arrow-down]
+++

```
  public synchronized void withdraw(double amount) {
    this.balance -= amount;
  }

  public synchronized double getBalance() {
    return balance;
  }

  // Бъг! - този метод също трябва да е синхронизиран!
  public void verifyAndWithdraw(double amount) {
    if (getBalance() >= amount) {
      withdraw(amount);
    }
  }

```

---

#### Мъртва хватка (Deadlock)
Получава, когато две или повече нишки се блокират една друга, всяка от тях притежаваща ключалка, от която друга нишка има нужда, но чакайки за ключалка, която някоя от другите нишки притежава.

@fa[arrow-down]
+++

Нишките не могат да бъдат прекратявани отвън.
Ключалките не могат да бъдат отнемани насилствено.
=> Единственият изход от мъртва хватка е рестартиране на JVM.

@fa[arrow-down]
+++

#### Предотвратяване
На теория:
- мониторите да се вземат винаги в същия ред 
- използване на един общ монитор 

@fa[arrow-down]
+++

За съжаление, на практика това често е невъзможно. В такива случаи:
- намаляване на синхронизираната секция, с цел избягване на притежаване на повече монитори 
- подреждаме мониторите спрямо някакъв признак

---

#### Комуникация между нишки

---

#### Busy wait
Нишките в дадено приложение често зависят от стойността на споделен обект, които очакват да бъде променен от друга нишка. Неефективен (и възможно некоректен) начин да постигнем това е т.нар. busy wait: в цикъл изчакваме събитието да се случи

@fa[arrow-down]
+++

```
  // Всеки месец се пуска нова нишка, която тегли сумата на месечната вноска 
  // от сметката на кредитополучателя 
  public void withdrawCreditPayment(double monthFee) {
    while (this.balance < monthFee) {
      // Стоим в цикъла докато няма достатъчно пари да погасят месечната вноска
      Thread.sleep(1000);
    }
    balance -= monthFee;
  }
```
---

#### Изчакване чрез wait()
Дадена нишка може да заяви, че иска да изчака, докато като дадено събитие се случи в друга нишка чрез метода wait() на java.lang.Object

@fa[arrow-down]
+++

```
  public synchronized void withdrawCreditPayment(double monthFee) {
    if (this.balance < monthFee) {
      try {
        // Изчакваме и освобождаваме монитора this
        this.wait();
      } catch (InterruptedException e) {
        // хвърля грешка, ако нишката бъде прекъсната
      }
    }
    balance -= monthFee;
  }
```
---

#### java.lang.Object.wait()
@ul
- Извикването на wait() винаги става в критична секция по обекта, който ползваме за монитор (в противен случай се хвърля java.lang.IllegalMonitorStateException)
- wait() освобождава текущия монитор и нишката преминава в статус “WAITING”
@ulend

@fa[arrow-down]
+++

Възможно е да извикаме wait() с аргумент за време – по този начин нишката ще се събуди, ако бъде известена или времето изтече.  
Винаги след събуждане проверявайте, дали събитието, за което чакате, в действителност е настъпило: шаблон, известен като “guarded wait”.

---

#### Известяване чрез notify()

Нишка може да извести чакащи нишки, че дадено събитие се е случило и те могат да продължат своето изпълнение. Това става чрез метода notify() на java.lang.Object

@fa[arrow-down]
+++

```
  // При депозиране на пари по сметка, уведомяваме чакащите нишки, 
  // че са постъпили средства по сметката
  public synchronized void deposit(double amount) {
    this.notify();
    this.balance += amount;
  }
```
---

#### java.lang.Object().notify()
- Събужда една нишка чакаща за съответния монитор
- Извикването на notify() винаги става в критична секция по обекта, който ползваме за монитор
- не освобождава монитора

@fa[arrow-down]
+++

Имаме два варианта:
- notify() – събужда една нишка 
- notifyAll() – събужда всички нишки

@fa[arrow-down]
+++

Ако имаме няколко чакащи нишки за текущия монитор, нямаме възможност да кажем коя/кои нишки да бъдат събудени или да бъдат събудени първи

---
#### notify() vs notifyAll()

notify() – събужда една произволна нишка, чакаща за този монитор. Полезно е само когато сме сигурни, че само една нишка може да продължи изпълнението си и не искаме да „платим“ цената да събудим всички


@fa[arrow-down]
+++

notifyAll() – събужда всички нишки. В много случаи, повече от една нишка може да продължи действието си след известяването си. Нишките се изпълняват последователно в синхронизираната секция по монитора след събуждането си.

@fa[arrow-down]
+++

В практиката по-често се ползва notifyAll(). Правилно имплементирана проверка в while() може да ни гарантира същото поведение като при notify() – макар и събудени повече нишки – те ще заспят отново, след като видят, че не могат да продължат.

---

#### Преизползване на нишки

---
#### Thread pool (executor) 
Kонцепция в конкурентното програмиране, при която „рециклираме“ нишките след края на тяхното изпълнение, с цел оптимизация.

@fa[arrow-down]
+++

Задава абстракция от управлението на жизнения цикъл на нишката (създаване, старт/стоп, преизползване)

@fa[arrow-down]
+++

Отделните runnable обекти се третират като „задачи“ и се трупат в опашка, и когато има свободни нишки в poolа, те изпълняват задачите на базата на зададени правила.

--- 

#### Executors API

```
// централен интерфейс
java.util.concurrent.Executor  
void execute(Runnable command)

// добавя възможност и за изпълнение на Callable обекти,
// които за разлика от Runnable, могат да върнат резултат
java.util.concurrent.ExecutorService
<T> Future<T> submit(Callable<T> task)

// задачите могат да се пускат след опредено закъснение
// или периодично на зададен интервал
java.util.concurrent.ScheduledExecutorService
ScheduledFuture schedule(Runnable r,long delay, TimeUnit tu) 
ScheduledFuture scheduleAtFixedRate(Runnable r,long delay, long period, TimeUnit tu)
```
---

#### Създаване на Executor

```
// предоставя статични методи фабрики за създаването на pools от нишки
java.util.concurrent.Executors

// pool-ът ще се състои само от една нишка, следователно 
// задачите ще се изпълняват последователно
static ExecutorService newSingleThreadExecutor()

// създава pool от нишки, който ще преизползва нишките,
// ако има налични, в противен случай ще направи нова.
// Нишките, който не се използвани през последната минута 
// ще бъдат премахнати
static ExecutorService newCachedThreadPool()

// създава pool, който ще се състои от фиксиран брой нишки. 
// Ако в опашката има повече задачи, отколкото налични нишки, 
// задачите не се обработват, докато не се освободи нишка
static ExecutorService newFixedThreadPool(int n)  

// pool който изпълнява задачи периодично или със закъснение
static ScheduledExecutorService newScheduledThreadPool(int size)
```

---

#### Спиране на Thread pool

Executor обект винаги трябва спира бъде експлицитно спрян с метода shutdown()

---

#### Атомарни променливи
- Имат същите свойства като volatile променливи, с разликата, че предоставят възможност за атомарни съставни операции

- Позволява lock-free, thread-safe конкурентно програмиране върху променливи.

- Използват специални хардуерни инструкции (“compare-and-swap”, CAS),  които позволяват избягването на ключалки


@fa[arrow-down]
+++

Предоставя атомарни имплементации на примитиви, масиви от примитиви и абстракция за атомарна референция (в пакета java.util.concurrent.atomic)

AtomicBoolean, AtomicInteger, AtomicLong, AtomicIntegerArray, AtomicLongArray, AtomicReference<ActualType>

---

#### Атомарни операции
- Всички имплементации имат методи get() и set() за достъп до съхраняваната променлива. Tе са еквивалентни на четене и модификация на volatile променлива

@fa[arrow-down]
+++

Предоставя методи, емулиращи атомарни операции, които не използват синхронизация

```
// thread-safe вариант на ++i (i=i+1)
atomicInt.incrementAndGet(); 

// thread safe вариант на i += x (i=i+x) 
atomicInt.addAndGet(x) 

// thread-safe вариант на if (ref == expected) { ref = update; } 
atomicRef.compareAndSet(expected, update)
```
---

#### Конкурентни колекции

Collections API предоставя имплементации няколко thread-safe колекции като:
Vector, Hashtable

@fa[arrow-down]
+++

Също така, има метод фабрика с който можем да си създадем thread-safe колекция.

```
static <T> Collection<T> synchronizedCollection(Collection<T> c)
```

@fa[arrow-down]
+++

Имат два основни недостатъка:
- не са достатъчно бързи при много конкурентни ползватели 
- не предоставят възможност за атомарни операции

---

#### Конкурентни колекции
- създадени специално за работа в конкурентна среда
- добавят възможности за:  
  - Lock-free паралелен достъп
  - Fail-safe итератори
  - Атомарни операции (пр. putIfAbsent)
  
---
__CopyOnWriteArrayList__

- Алтернатива на синхронизираните имплементации на ArrayList
- Предоставя оптимизиран достъп до елементите, след като позволява lock-free паралелно четене
- “Fail-safe shapshot” итератор
- Всяка модификация предизвиква копиране на масива
- Атомарни операции: boolean addIfAbsent(E e);

@fa[arrow-down]
+++

Използването на тази структура е подходящо само когато броят на четенията от масива значително надвишава броя на модификациите. В противен случай, структурата е изключително неефективна

--- 

__ConcurrentHashMap__
- Алтернатива на синхронизираните версии на java.util.HashMap
- Паралелен lock-free достъп за четене
- Паралелен (но лимитиран) достъп за писане 
- Fail-safe и “Weekly consistent“ итератор
- Атомарни операции: V putIfAbsent(K key, V value)

@fa[arrow-down]
+++

Най-популярната колекция от j.u.c библиотеката, почти винаги е подходяща да се използва за замяната на съществуващите thread-safe варианти на HashMap

--- 

___BlockingQueue___

- Имплементация на блокираща опашка (“Producer-Consumer” опашка)
Блокира когато 
- опашката е празна и някой се опитва да чете (консумира) от нея. При първи запис, бива автоматично нотифицирана 
- oпашката е пълна и някой се опитва да пише (продуцира) в нея. При първо четене, бива автоматично нотифицирана

@fa[arrow-down]
+++

ArrayBlockingQueue – основна имплементация. Опашката пази елементите си в масив, който не може да променя размера си.
```
BlockingQueue<String> queue = new ArrayBlockingQueue<>(4);
```

@fa[arrow-down]
+++

BlockingQueue API

---
